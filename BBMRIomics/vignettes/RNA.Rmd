---
title: "RNA "
output:
  html_document:
    highlight: tango
    toc: true
    toc_float:
      collapsed: false
bibliography: BBMRIomics.bib
---

```{r, child="_setup.Rmd"}
```

# Library preparation and alignment #

Detailed description of the RNASeq data generation and preprocessing
can be found in the supplementary material of the paper by Zhernakova
et al. [@Zhernakova2017]

# Feature quantification read counts #

Gene read counts are generated using
[htseq](http://www-huber.embl.de/HTSeq/doc/count.html) using mode
`union` for handling overlapping exons.

Reference annotation used is from ensembl:
[](http://ftp.ensembl.org/pub/release-71/gtf/homo_sapiens/Homo_sapiens.GRCh37.71.gtf.gz")
but only chromosomes 1-22 and X, Y (and MT) are retained.


## Prepare gene annotation ##

For convenience we create a `TxDb`-package. For more information on
using a `TxDb`-package see
[GenomicFeatures](http://bioconductor.org/packages/release/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.pdf).

*** Note this requires sudo rights to install and use sudo -i to load /etc/profile with global R_SITE_LIB =/opt/... ***

```{r, txdb, eval=FALSE}

library(GenomicFeatures)
library(rtracklayer)
gtf <- "ftp://ftp.ensembl.org/pub/release-71/gtf/homo_sapiens/Homo_sapiens.GRCh37.71.gtf.gz"
txdb <- makeTxDbFromGFF(gtf, organism="Homo sapiens")

##Hack by James MacDonald (https://support.bioconductor.org/p/89855/)
con <- dbconn(txdb)
## insert a Resource URL entry in the metadata table,
## pointing to the ftp site where the data were procured
DBI::dbGetQuery(con, "INSERT INTO metadata VALUES ('Resource URL', 'ftp://ftp.ensembl.org/pub/release-71/gtf/homo_sapiens/Homo_sapiens.GRCh37.71.gtf.gz');")

makeTxDbPackage(txdb,
                version = "0.0.1",
                maintainer = "m. van Iterson <m.van_iterson@lumc.nl>",
                author = "m. van Iterson",
                destDir= ".",
                license = "Artistic-2.0",
                pkgname = "TxDb.Hsapiens.Ensembl.v71")

library(devtools)
install("./TxDb.Hsapiens.Ensembl.v71")

```

Now can use the Ensembl v71 annoation like any other `TxDb`-package.

```{r, txdbexample, eval=FALSE}
library(TxDb.Hsapiens.Ensembl.v71)
(txdb <- TxDb.Hsapiens.Ensembl.v71)
genes(txdb)
```

## Prepare sample metadata ##

```{r, coldatarna, eval=FALSE}
library(BBMRIomics)
ids <- getView("getIds", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
runs <- getView("getRNASeqRuns", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
runs <- runs[!duplicated(runs$run_id),] ##drop overlapping freezes
runs <- subset(runs, qc == "passed") ##keep those passing qc
runs <- subset(runs, type != "replicate") ##drop replicated

##now we have still original, reruns and merged runs
merged <- subset(runs, type == "merged") ##select
merged <- subset(merged, !(run_id %in% c("BD1NYRACXX-5-27_AC1JL5ACXX-6-27", "AC1C40ACXX-6-15_BD2D5MACXX-6-15"))) ##these have were already merged in freeze one and have new merges so drop
original <- subset(runs, !(ids %in% merged$ids) & type == "original")
runs <- rbind(merged, original)
dim(runs)
table(runs$type)

mid <- match(runs$ids, ids$ids)
runs$uuid <- ids$uuid[mid]

rdb <- getView("getStats", usrpwd=RP3_MDB_USRPWD, url=RP3_RDB)
rdb <- do.call('cbind', rdb)

runs <- merge(runs, rdb, by.x="run_id", by.y="ids", all.x=TRUE)

relations <- getView("getRelations", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
relations <- merge(relations, runs[, c("run_id", "ids")], by="ids") ##add run_id to relations
##renaming relation_id's to uuid's
mid <- match(relations$relation_id, ids$ids)
relations$relation_uuid <- NA
relations$relation_uuid[!is.na(mid)] <- ids$uuid[mid[!is.na(mid)]]

##harmonize phenotypes
source(file.path(path.package("BBMRIomics"), "scripts/Phenotype_Helpers.R"), verbose=FALSE)
source(file.path("~/BBMRIomics/BBMRIomics", "inst/scripts/Phenotype_Helpers.R"), verbose=FALSE)
phenotypes <- cleanPhenotypes()
colData <- merge(phenotypes, runs, by="ids", all.y=TRUE) ##add phenotypes

colData <- merge(colData, relations[,c("run_id", "gonl_id", "relation_type", "relation_uuid")], by="run_id", all.x=TRUE) ##add relations

table(colData$relation_type)

unrel <- subset(colData, is.na(relation_type) & !duplicated(uuid))
rel <- subset(colData, !is.na(relation_type) & !is.na(relation_uuid) & !duplicated(uuid))

intersect(unrel$uuid, rel$relation_uuid) ##BIOSA71B9B5A? Fix this
intersect(unrel$relation_uuid, rel$uuid) ##?

rel$pairs <- apply(rel[, c("uuid", "relation_uuid")], 1, function(x) paste0(sort(x), collapse=":"))

rel[order(rel$pairs)[1:10], c("uuid", "relation_uuid", "relation_type", "pairs")]

##drop pairs
rel <- rel[!duplicated(rel$pairs), ]
rel[order(rel$pairs)[1:25], c("uuid", "relation_uuid", "relation_type", "pairs")]


intersect(rel$uuid, rel$relation_uuid)

id <- "BIOSECD69F26"
subset(rel, uuid == id | relation_uuid == id, c(ids, uuid, relation_type, relation_uuid, pairs))




colData <- rbind(unrel, rel[,-116])


dim(colData)

##renaming columns
colnames(colData) <- gsub("^type$", "run_type", colnames(colData))

head(colData)
##ordering
first <- match(c("ids", "uuid", "biobank_id", "run_type", "qc", "relation_type", "relation_uuid", "gonl_id", "run_id"), colnames(colData))

colData <- cbind(colData[, first], colData[, -first])
colData <- colData[, !(colnames(colData) %in% c("ids", "rna_id", "freeze"))]

rownames(colData) <- colData$uuid

imputation <- getView("getImputations", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
hrc <- subset(imputation, imputation_reference=="HRC")

uuids <- intersect(colData$uuid, hrc$uuid)
colData <- colData[colData$uuid %in% uuids, ]
mid <- match(colData$uuid, hrc$uuid)
colData$hrc_id <- hrc$imputation_id[mid]
dim(colData)

```


## Prepare count table ##

```{r, countdata, eval=FALSE}
library(BiocParallel)
register(MulticoreParam(8, log=TRUE))
files <- list.files(file.path(VM_BASE_DATA, "RNASeq/v2.1.3/", "gene_read"), full.names=TRUE, pattern="gene.read.count.gz$")
##select runs

files <- files[gsub(".gene.read.count.gz", "", basename(files)) %in% colData$run_id]

head(read.table(files[1], header=TRUE, check.names=FALSE)) ##checking the first few lines
tmp <- bplapply(files, read.table, header=TRUE, check.names=FALSE)
table(unlist(lapply(tmp, nrow))) ##checking all the same length
for(i in 2:length(tmp)) { ##checking all genes same position
    if(!all.equal(tmp[[1]]$gene, tmp[[i]]$gene))
        message("not equal:", i)
}
rownames <- as.character(tmp[[1]]$gene)
colnames <- gsub("\\.gene.read.count.gz", "", basename(files))
counts <- matrix(nrow=nrow(tmp[[1]]), ncol=length(tmp),
                 dimnames=list(rownames, colnames))
for(i in 1:length(tmp)) counts[,i] <- tmp[[i]][,2]
counts[1:5, 1:5]
mid <- match(colnames(counts), colData$run_id)
colnames(counts) <- colData$uuid[mid]
```

```{r, rowdatarna, eval=FALSE}
library(TxDb.Hsapiens.Ensembl.v71)
rowRanges <- genes(TxDb.Hsapiens.Ensembl.v71)
library(GenomeInfoDb)
rowRanges <- keepSeqlevels(rowRanges, c(1:22, "X", "Y", "MT"))
rowRanges
head(colData)
counts[1:5, 1:5]
counts <- makeSE(counts, colData, rowRanges, note="")
save(counts, file = file.path(VM_BASE_DATA, "RNASeq/v2.1.3/gene_read/", paste0("rnaSeqData_ReadCounts_cleaned.RData")))
```

## Miscellaneous ##

Code to calculate gene-level GC-content.

```{r, gcrna, eval=FALSE}
library(AnnotationHub)
ah <- AnnotationHub()
query(ah, c("ensembl", "sapiens", "71"))

gtf <- rtracklayer::import(ah["AH7666"]$sourceurl)

library(GenomeInfoDb)
gtf <- keepSeqlevels(gtf, c(1:22, "X", "Y", "MT"))
gtf <- gtf[order(gtf)] ##now we have `cut and sorted` as on the VM

seqlevels(gtf) <- mapSeqlevels(seqlevels(gtf), "UCSC")  ##for use in combination with `BSgenome.Hsapiens.UCSC.hg19`
genome(gtf) <- "hg19" ##for use in combination with `BSgenome.Hsapiens.UCSC.hg19`

genes <- split(gtf, mcols(gtf)$gene_id)

register(MulticoreParam(8))
gc <- bplapply(genes, function(x) {
    require(BSgenome.Hsapiens.UCSC.hg19)
    require(Rsamtools)
    require(Biostrings)
    seqs <- getSeq(Hsapiens, reduce(x))
    alf <- as.matrix(alphabetFrequency(seqs, as.prob=TRUE)[, c("G", "C")], ncol=2)
    gc <- rowSums(alf)
    mean(gc)
})
gc <- do.call("rbind", gc)
all.equal(names(genes), rownames(gc))
mcols(genes)$gc <- gc
genes

```
